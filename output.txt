Sun Jan 24 13:01:20 PST 2021
Linux csslab1.uwb.edu 3.10.0-1160.11.1.el7.x86_64 #1 SMP Fri Dec 18 16:34:56 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux
uid=930027(schau623) gid=2120930027(schau623) groups=2120930027(schau623),605559(lab-access)
=====================================================
1. Compiles without warnings with -Wall -Wextra flags
=====================================================
=====================================================
2. Runs and produces correct output
=====================================================
Starting test01
* Testing ==, !=, [] and copy constructor
b1:    [hello=5]   
  N   [world=42]


b3:    [hello=5]   
  N   [world=42]


Ending tes01
Starting test02
* Testing traversal
Ending test02
Starting test03
* Testing rebalance
Ending test03
Starting getAllTest. Test is by Alan and Steven :)
getAll Test Passed :)
Starting catTest
Ending catTest
Starting AC test01
* Testing basic autocomplete
Ending tesAC01
Starting AC test02
* Testing cities autocomplete
Ending tesAC02
Starting studentACTest01
Ending studentACTest
Starting studentACTest02
Ending studentACTest02
=====================================================
3. clang-tidy warnings are fixed
=====================================================
=====================================================
4. clang-format does not find any formatting issues
=====================================================
Running clang-format on ./autocomplete.cpp
2d1
< #include <sstream>
4a4
> #include <sstream>
11,14c11,12
< 
< string Autocomplete::trim(string& line)
< {
<   const char* emptySpace = " \t\v\r\n";
---
> string Autocomplete::trim(string &line) {
>   const char *emptySpace = " \t\v\r\n";
17c15
<   return first == last ? string(): line.substr(first, last - first + 1);
---
>   return first == last ? string() : line.substr(first, last - first + 1);
20,39c18,33
< void Autocomplete::readFile(const string &fileName){
<     string s;
<     uint64_t i;
<     string t;
<     ifstream ifs(fileName);
<     getline(ifs, s);
<     vector<pair<string, uint64_t>> v;
<     if(ifs.is_open()){
<     while(getline(ifs, s)) 
<       {
<           stringstream ss(s);
<           ss >> i;
<           getline(ss, t);
<           pair<string, uint64_t> p;
<           p.first = trim(t);
<           p.second = i;
<           phrases.insert(p);
<       }
<       phrases.rebalance();
<       ifs.close();
---
> void Autocomplete::readFile(const string &fileName) {
>   string s;
>   uint64_t i;
>   string t;
>   ifstream ifs(fileName);
>   getline(ifs, s);
>   vector<pair<string, uint64_t>> v;
>   if (ifs.is_open()) {
>     while (getline(ifs, s)) {
>       stringstream ss(s);
>       ss >> i;
>       getline(ss, t);
>       pair<string, uint64_t> p;
>       p.first = trim(t);
>       p.second = i;
>       phrases.insert(p);
41c35,38
<     return;
---
>     phrases.rebalance();
>     ifs.close();
>   }
>   return;
44,45c41
< bool Autocomplete::sortByWeight(BSTMap::value_type &a, BSTMap::value_type &b) 
< {
---
> bool Autocomplete::sortByWeight(BSTMap::value_type &a, BSTMap::value_type &b) {
49,51c45,46
< vector<BSTMap::value_type> Autocomplete::complete(const string &prefix) const 
< {
<   vector<BSTMap::value_type> v =  phrases.getAll(prefix);
---
> vector<BSTMap::value_type> Autocomplete::complete(const string &prefix) const {
>   vector<BSTMap::value_type> v = phrases.getAll(prefix);
55d49
< 
Running clang-format on ./bstmap.cpp
14,17c14
< BSTMap::BSTMap(const BSTMap &bst) 
< {
<   root = copyHelper(bst.root);
< }
---
> BSTMap::BSTMap(const BSTMap &bst) { root = copyHelper(bst.root); }
19,23c16,18
< //copies tree recursively
< BSTMap::Node* BSTMap::copyHelper(Node* copy)
< {
<   if(copy == nullptr)
<   {
---
> // copies tree recursively
> BSTMap::Node *BSTMap::copyHelper(Node *copy) {
>   if (copy == nullptr) {
26,30c21,25
<     Node* copyNode = new Node();
<     copyNode->data = copy->data;
<     copyNode->right = copyHelper(copy->right);
<     copyNode->left = copyHelper(copy->left);
<     return copyNode;
---
>   Node *copyNode = new Node();
>   copyNode->data = copy->data;
>   copyNode->right = copyHelper(copy->right);
>   copyNode->left = copyHelper(copy->left);
>   return copyNode;
36,40c31,33
< BSTMap::BSTMap(const vector<value_type> &v) 
< {
<   for(int i = 0; i < v.size(); i++)
<   {
<     Node* theNode = new Node();
---
> BSTMap::BSTMap(const vector<value_type> &v) {
>   for (int i = 0; i < v.size(); i++) {
>     Node *theNode = new Node();
47,91c40,76
< BSTMap::~BSTMap() 
< {
<   clear();
< }
< 
< bool BSTMap::erase(const key_type &k){
<     if(contains(k) == false)
<     {
<       return false;
<     }
<     else
<     {
<       eraseHelper(root, k);
<       return true;
<     }
<    
< }
< 
< BSTMap::Node* BSTMap::eraseHelper(Node* current, const key_type &k){
<     if(current == nullptr)
<             return nullptr;
<         if(k < current->data.first)
<             current->left = eraseHelper(current->left, k);
<         else if(k > current->data.first)
<             current->right = eraseHelper(current->right, k);
<         else{
<             if(current->left == nullptr && current->right == nullptr)
<                 return nullptr;
<             else if((current->left != nullptr) && (current->right == nullptr))
<                 return current->left;
<             else if(current->right != nullptr && current->left == nullptr)
<                 return current->right;
<             auto successor = current->right;
<             while(successor->left != nullptr)
<                 successor = successor->left;
<         current->data.first = successor->data.first;
<             current->right = eraseHelper(current->right, successor->data.first);
<         }
<         return current;
< }
< 
< //inserts new nodes into tree
< void BSTMap::insert(value_type toAdd)
< {
<   Node* newNode = new Node();
---
> BSTMap::~BSTMap() { clear(); }
> 
> bool BSTMap::erase(const key_type &k) {
>   if (contains(k) == false) {
>     return false;
>   } else {
>     eraseHelper(root, k);
>     return true;
>   }
> }
> 
> BSTMap::Node *BSTMap::eraseHelper(Node *current, const key_type &k) {
>   if (current == nullptr)
>     return nullptr;
>   if (k < current->data.first)
>     current->left = eraseHelper(current->left, k);
>   else if (k > current->data.first)
>     current->right = eraseHelper(current->right, k);
>   else {
>     if (current->left == nullptr && current->right == nullptr)
>       return nullptr;
>     else if ((current->left != nullptr) && (current->right == nullptr))
>       return current->left;
>     else if (current->right != nullptr && current->left == nullptr)
>       return current->right;
>     auto successor = current->right;
>     while (successor->left != nullptr)
>       successor = successor->left;
>     current->data.first = successor->data.first;
>     current->right = eraseHelper(current->right, successor->data.first);
>   }
>   return current;
> }
> 
> // inserts new nodes into tree
> void BSTMap::insert(value_type toAdd) {
>   Node *newNode = new Node();
96,100c81,83
< //recursively traverses tree and addes new nodes
< BSTMap::Node* BSTMap::insertHelper(Node* toAdd, Node* current)
< {
<   if(current == nullptr)
<   {
---
> // recursively traverses tree and addes new nodes
> BSTMap::Node *BSTMap::insertHelper(Node *toAdd, Node *current) {
>   if (current == nullptr) {
102,104c85
<   }
<   else if(current->data.first > toAdd->data.first)
<   {
---
>   } else if (current->data.first > toAdd->data.first) {
106,108c87
<   }
<   else if(current->data.first <= toAdd->data.first)
<   {
---
>   } else if (current->data.first <= toAdd->data.first) {
110d88
<     
115d92
< 
117,120c94,95
< void BSTMap::clear() 
< {
<   if(root == nullptr)
<   {
---
> void BSTMap::clear() {
>   if (root == nullptr) {
126,130c101,103
< //recursively traverses tree and deletes nodes
< void BSTMap::clearHelper(Node* current)
< {
<   if(current == nullptr)
<   {
---
> // recursively traverses tree and deletes nodes
> void BSTMap::clearHelper(Node *current) {
>   if (current == nullptr) {
138d110
< 
140,143c112,113
< bool BSTMap::empty() const 
< { 
<   if(root == nullptr)
<   {
---
> bool BSTMap::empty() const {
>   if (root == nullptr) {
149,151c119,120
< //returns size of tree based on number of nodes
< int BSTMap::size() const 
< {
---
> // returns size of tree based on number of nodes
> int BSTMap::size() const {
156,160c125,127
< //returns size of tree based on number of nodes
< int BSTMap::sizeHelper(Node* root) const
< {
<   if(root == nullptr)
<   {
---
> // returns size of tree based on number of nodes
> int BSTMap::sizeHelper(Node *root) const {
>   if (root == nullptr) {
162,164c129
<   } 
<   else
<   {
---
>   } else {
170,173c135
< bool BSTMap::contains(const key_type &key) const 
< { 
<   return contains(root, key); 
< }
---
> bool BSTMap::contains(const key_type &key) const { return contains(root, key); }
175,180c137,140
< //contains overload, recursively traverses tree searching for key_type &key
< bool BSTMap::contains(Node* curr, const key_type &key) const 
< {
<   //cout << key << endl;
<   if(curr == nullptr)
<   {
---
> // contains overload, recursively traverses tree searching for key_type &key
> bool BSTMap::contains(Node *curr, const key_type &key) const {
>   // cout << key << endl;
>   if (curr == nullptr) {
183,184c143
<   if(curr->data.first == key)
<   {
---
>   if (curr->data.first == key) {
187,188c146,147
<   
<   return(contains(curr->left, key) || contains(curr->right, key));
---
> 
>   return (contains(curr->left, key) || contains(curr->right, key));
194,198c153,155
< BSTMap::mapped_type &BSTMap::operator[](const key_type &k) 
< {
<   if(contains(k))
<   {
<     Node* theNode = bracketHelper(k, root);
---
> BSTMap::mapped_type &BSTMap::operator[](const key_type &k) {
>   if (contains(k)) {
>     Node *theNode = bracketHelper(k, root);
201c158
<   pair<string,uint64_t> newNode;
---
>   pair<string, uint64_t> newNode;
205c162
<   Node* theNode = bracketHelper(k, root);
---
>   Node *theNode = bracketHelper(k, root);
209,213c166,168
< //recursively adds new node to tree
< BSTMap::Node* BSTMap::bracketHelper(const key_type &k, Node* curr)
< {
<   if(curr == nullptr)
<   {
---
> // recursively adds new node to tree
> BSTMap::Node *BSTMap::bracketHelper(const key_type &k, Node *curr) {
>   if (curr == nullptr) {
215,217c170
<   }
<   else if(k == curr->data.first)
<   {
---
>   } else if (k == curr->data.first) {
219,221c172
<   }
<   else if(k > curr->data.first)
<   {
---
>   } else if (k > curr->data.first) {
223,225c174
<   }
<   else
<   {
---
>   } else {
230,232c179,180
< //retireves all words starting with key_type &k
< vector<BSTMap::value_type> BSTMap::getAll(const key_type &k) const 
< {
---
> // retireves all words starting with key_type &k
> vector<BSTMap::value_type> BSTMap::getAll(const key_type &k) const {
238,242c186,190
< //recursively traverses tree and adds to vector each word starting with key_type &k
< void BSTMap::getAllHelper(vector<value_type>& vect, Node* curr, const key_type &k) const
< {
<   if(curr == nullptr)
<   {
---
> // recursively traverses tree and adds to vector each word starting with
> // key_type &k
> void BSTMap::getAllHelper(vector<value_type> &vect, Node *curr,
>                           const key_type &k) const {
>   if (curr == nullptr) {
245,246c193
<   if(curr->data.first.rfind(k, 0) == 0)
<   {
---
>   if (curr->data.first.rfind(k, 0) == 0) {
256,259c203
< int BSTMap::height() const 
< { 
<   return getHeight(root); 
< }
---
> int BSTMap::height() const { return getHeight(root); }
263,266c207,208
< int BSTMap::getHeight(const Node* n)
< { 
<   if(n == nullptr)
<   {
---
> int BSTMap::getHeight(const Node *n) {
>   if (n == nullptr) {
269,270c211
<   if(n->left == nullptr && n->right == nullptr)
<   {
---
>   if (n->left == nullptr && n->right == nullptr) {
275c216
<   return max(left,right)+1; 
---
>   return max(left, right) + 1;
280,283c221,222
< size_t BSTMap::count(const string &k) const 
< { 
<   if(!contains(k))
<   {
---
> size_t BSTMap::count(const string &k) const {
>   if (!contains(k)) {
291,292c230
< void BSTMap::inorder(void visit(const value_type &item)) const 
< {
---
> void BSTMap::inorder(void visit(const value_type &item)) const {
295,304c233,241
< //inorder overload
< void BSTMap::inorder(Node* current, void visit(const value_type &item)) const{
<     if(current == nullptr)
<     {
<         return;
<     }
<     inorder(current->left, visit);
<     value_type v = current->data;
<     visit(v);
<     inorder(current->right, visit);
---
> // inorder overload
> void BSTMap::inorder(Node *current, void visit(const value_type &item)) const {
>   if (current == nullptr) {
>     return;
>   }
>   inorder(current->left, visit);
>   value_type v = current->data;
>   visit(v);
>   inorder(current->right, visit);
308,309c245
< void BSTMap::preorder(void visit(const value_type &item)) const 
< {
---
> void BSTMap::preorder(void visit(const value_type &item)) const {
312,321c248,256
< //preorder overload
< void BSTMap::preorder(Node* current, void visit(const value_type &item)) const{
<     if(current == nullptr)
<     {
<         return;
<     }
<     value_type v = current->data;
<     visit(v);
<     preorder(current->left, visit);
<     preorder(current->right, visit);
---
> // preorder overload
> void BSTMap::preorder(Node *current, void visit(const value_type &item)) const {
>   if (current == nullptr) {
>     return;
>   }
>   value_type v = current->data;
>   visit(v);
>   preorder(current->left, visit);
>   preorder(current->right, visit);
325,326c260
< void BSTMap::postorder(void visit(const value_type &item)) const 
< {
---
> void BSTMap::postorder(void visit(const value_type &item)) const {
330,339c264,273
< //postorder overload
< void BSTMap::postorder(Node* current, void visit(const value_type &item)) const{
<     if(current == nullptr)
<     {
<         return;
<     }
<     postorder(current->left, visit);
<     postorder(current->right, visit);
<     value_type v = current->data;
<     visit(v);
---
> // postorder overload
> void BSTMap::postorder(Node *current,
>                        void visit(const value_type &item)) const {
>   if (current == nullptr) {
>     return;
>   }
>   postorder(current->left, visit);
>   postorder(current->right, visit);
>   value_type v = current->data;
>   visit(v);
344,346c278,279
< void BSTMap::rebalance() 
< {
<   vector<Node*> save;
---
> void BSTMap::rebalance() {
>   vector<Node *> save;
349c282
<   root = rebalanceHelper(save, 0, n-1);
---
>   root = rebalanceHelper(save, 0, n - 1);
351,355c284,286
< //stores nodes in a vector
< void BSTMap::storeNodes(Node* curr, vector<Node*> &save)
< {
<   if(curr == nullptr)
<   {
---
> // stores nodes in a vector
> void BSTMap::storeNodes(Node *curr, vector<Node *> &save) {
>   if (curr == nullptr) {
362,366c293,296
< //rebalances tree
< BSTMap::Node* BSTMap:: rebalanceHelper(vector<Node*> &save, int start, int end)
< {
<   if(start > end)
<   {
---
> // rebalances tree
> BSTMap::Node *BSTMap::rebalanceHelper(vector<Node *> &save, int start,
>                                       int end) {
>   if (start > end) {
369,372c299,302
<   int mid = (start + end)/2;
<   Node* root = save[mid];
<   root->left = rebalanceHelper(save, start, mid-1);
<   root->right = rebalanceHelper(save, mid+1, end);
---
>   int mid = (start + end) / 2;
>   Node *root = save[mid];
>   root->left = rebalanceHelper(save, start, mid - 1);
>   root->right = rebalanceHelper(save, mid + 1, end);
378,379c308
< bool BSTMap::operator==(const BSTMap &other) const 
< { 
---
> bool BSTMap::operator==(const BSTMap &other) const {
383,387c312,314
< //recursively traverses both trees and compares them
< bool BSTMap::isSameTree(Node* tree1, Node* tree2) const
< {
<   if(tree1 == nullptr && tree2 == nullptr)
<   {
---
> // recursively traverses both trees and compares them
> bool BSTMap::isSameTree(Node *tree1, Node *tree2) const {
>   if (tree1 == nullptr && tree2 == nullptr) {
389,391c316,317
<   }
<   else if((tree1 == nullptr && tree2 != nullptr) || (tree1 != nullptr && tree2 == nullptr))
<   {
---
>   } else if ((tree1 == nullptr && tree2 != nullptr) ||
>              (tree1 != nullptr && tree2 == nullptr)) {
393,395c319
<   }
<   else if(tree1->data != tree2->data)
<   {
---
>   } else if (tree1->data != tree2->data) {
398c322,323
<   return (isSameTree(tree1->left, tree2->left) && isSameTree(tree1->right, tree2->right));
---
>   return (isSameTree(tree1->left, tree2->left) &&
>           isSameTree(tree1->right, tree2->right));
402,403c327
< bool BSTMap::operator!=(const BSTMap &other) const 
< { 
---
> bool BSTMap::operator!=(const BSTMap &other) const {
Running clang-format on ./bstmapprinter.cpp
9,10c9
< ostream &operator<<(ostream &out, const BSTMap::Node &n) 
< {
---
> ostream &operator<<(ostream &out, const BSTMap::Node &n) {
17,18c16
< ostream &operator<<(ostream &out, const BSTMap &bst) 
< {
---
> ostream &operator<<(ostream &out, const BSTMap &bst) {
20c18
<   //BSTMap::printSideways(out, bst.root);
---
>   // BSTMap::printSideways(out, bst.root);
22c20
<    //BSTMap::printVertical([out], bst.root);
---
>   // BSTMap::printVertical([out], bst.root);
36,37c34
< ostream &BSTMap::printSideways(ostream &out, const Node *curr, int level) 
< {
---
> ostream &BSTMap::printSideways(ostream &out, const Node *curr, int level) {
Running clang-format on ./main.cpp
1d0
< #include "bstmap.h"
2a2
> #include "bstmap.h"
10c10
< /**/void testBSTAll();
---
> /**/ void testBSTAll();
Running clang-format on ./testac.cpp
37,38c37
< void studentACTest01()
< {
---
> void studentACTest01() {
51,52c50
< void studentACTest02()
< {
---
> void studentACTest02() {
75d72
< 
Running clang-format on ./testbst.cpp
110,111c110
< void getAllTest()
< {
---
> void getAllTest() {
128c127
<   
---
> 
140,142c139,140
< void catTest()
< {
<    cout << "Starting catTest" << endl;
---
> void catTest() {
>   cout << "Starting catTest" << endl;
=====================================================
5. No memory leaks using g++
=====================================================
